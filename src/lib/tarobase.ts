// Generated by TaroBase SDK Generator: 2026-02-06T14:30:57.852Z
// Edits may be overwritten by subsequent runs!

import { get, set, subscribe, setMany as tarobaseSetMany } from '@tarobase/js-sdk';
import { getFiles, setFile } from '@tarobase/js-sdk';
import { PublicKey } from '@solana/web3.js';
import { runQuery } from '@tarobase/js-sdk'; 


// --- SDK Utilities ---

/**
 * Helper function to check if a value is a Time.Now value
 */
const isServerTimeNow = (value: any): value is TimeOperation => {
  return (
    value &&
    typeof value === "object" &&
    value.operation === "time" &&
    value.value === "now"
  );
};

/**
 * Helper function to check if a value is an Increment operation
 */
const isIncrementOperation = (value: any): value is IncrementOperation => {
  return (
    value &&
    typeof value === "object" &&
    value.operation === "increment" &&
    typeof value.value === "number"
  );
};

/**
 * Time utility for server-time values
 *
 * Use this when you want to store the current server time in a numeric field
 *
 * Example:
 * // For a schema with { createdAt: "Int" } or { createdAt: "UInt" }
 * await setPost("123", {
 *   title: "My Post",
 *   createdAt: Time.Now  // Will be stored as the server's current timestamp
 * });
 */
export interface TimeOperation {
  operation: string;
  value: string;
}

/**
 * Increment utility for incrementing/decrementing numeric fields
 *
 * Use this when you want to increment or decrement a numeric field by a specific amount
 *
 * Example:
 * // For a schema with { viewCount: "UInt" } or { balance: "Int" }
 * await updatePost("123", {
 *   viewCount: Increment.by(1)  // Increments viewCount by 1
 * });
 * await updateAccount("456", {
 *   balance: Increment.by(-50)  // Decrements balance by 50
 * });
 */
export interface IncrementOperation {
  operation: string;
  value: number;
}

export type TokenName = 'USDC' | 'SOL' | 'other';
export interface TokenAmount {
  type: 'token';
  name: TokenName;
  amount: number; // User-friendly amount (e.g., 10.5 SOL)
}

/**
 * AddressType represents a Solana public key for use in request data.
 */
export interface AddressType {
  type: 'address';
  publicKey: PublicKey | string;
}

/**
 * Helper function to check if a value is a TokenAmount value
 */
const isTokenAmount = (value: any): value is TokenAmount => {
  return value && typeof value === 'object' && value.type === 'token';
};

/**
 * Helper function to check if a value is an AddressType value
 */
const isAddressType = (value: any): value is AddressType => {
    // Check for the 'address' type property and that publicKey is an instance of PublicKey
    return value && typeof value === 'object' && value.type === 'address';
};


/**
 * Transforms special values (Time.now, Token.amount, Address.publicKey) in an object
 * to the format expected by the backend before sending the request.
 * This function is recursive and handles nested objects and arrays.
 */
const transformValues = (data: any): any => {
  // Handle null or non-object/array types directly
  if (!data || typeof data !== 'object') {
    return data;
  }

  // Check for specific object types first using type guards
  if (isServerTimeNow(data)) {
    // Pass Time.Now object as is; backend interprets it
    return { operation: 'time', value: 'now' };
  } else if (isIncrementOperation(data)) {
    // Pass Increment operation as is; backend interprets it
    return { operation: 'increment', value: data.value };
  } else if (isTokenAmount(data)) {
    // Convert user-friendly amount to backend's integer format based on decimals
    const { name, amount } = data; // Safe access due to type guard
    if (name === 'USDC') {
      return Math.round(amount * 10 ** 6); // 6 decimals for USDC
    } else if (name === 'SOL') {
      return Math.round(amount * 10 ** 9); // 9 decimals for SOL
    } else {
      // Assume a default of 6 decimals for custom tokens
      return Math.round(amount * 10 ** 6);
    }
  } else if (isAddressType(data)) {
     // Convert AddressType to its base58 string representation for the backend
     if (typeof data.publicKey === 'string') {
      return data.publicKey;
     } else {
      return data.publicKey.toBase58(); // Safe access due to type guard
     }
  }

  // Handle arrays: recursively transform each item
  if (Array.isArray(data)) {
    // Use map with explicit typing for clarity
    return data.map((item: any) => transformValues(item));
  }

  // Handle regular objects: recursively transform each property
  // Create a new object to avoid modifying the original
  const result: Record<string, any> = {};
  for (const key in data) {
    // Use safer check for own properties
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      result[key] = transformValues(data[key]);
    }
  }
  return result;
};

// --- SDK Helper Objects ---

export const Token: {
  /**
   * Creates a TokenAmount object representing a specific amount of a token.
   * @param name The name of the token (e.g., 'USDC', 'SOL').
   * @param amount The user-friendly amount (e.g., 10.5 for 10.5 USDC).
   */
  amount: (name: TokenName, amount: number) => TokenAmount;
  /**
   * Converts a TokenAmount object back to its integer representation based on decimals.
   * Useful if you need the raw integer value on the client side.
   */
  convert: (amount: TokenAmount) => number;
} = {
  amount: (name: TokenName, amount: number): TokenAmount => ({
    type: 'token',
    name,
    amount,
  }),
  convert: (amount: TokenAmount): number => {
    // This logic mirrors the transformation in transformValues
    if (amount.name === 'USDC') {
      return Math.round(amount.amount * 10 ** 6);
    } else if (amount.name === 'SOL') {
      return Math.round(amount.amount * 10 ** 9);
    }
    return Math.round(amount.amount * 10 ** 6); // Default or handle 'other'
  },
};

export const Time: {
  /**
   * Represents the server's current time. Use this value for 'Int' or 'UInt' fields
   * in request data where you want the server to insert the timestamp.
   */
  Now: TimeOperation;
} = {
  Now: { operation: "time", value: "now" }
};

export const Increment: {
  /**
   * Creates an increment/decrement operation for numeric fields.
   * Use positive values to increment, negative values to decrement.
   * @param value The amount to increment (positive) or decrement (negative)
   *
   * Example:
   * // Increment a counter by 1
   * await updatePost("123", { viewCount: Increment.by(1) });
   *
   * // Decrement a balance by 50
   * await updateAccount("456", { balance: Increment.by(-50) });
   */
  by: (value: number) => IncrementOperation;
} = {
  by: (value: number): IncrementOperation => ({
    operation: "increment",
    value
  })
};

export const Address: {
  /**
   * Creates an AddressType object from a PublicKey instance or a base58 string.
   * Validates the input and throws an error if invalid.
   * @param key A PublicKey instance or a base58 encoded public key string.
   */
  publicKey: (key: PublicKey | string) => AddressType;
} = {
  publicKey: (key: PublicKey | string): AddressType => {
    let pkInstance: PublicKey;
    if (typeof key === 'string') {
      try {
        // Validate and create PublicKey from string
        pkInstance = new PublicKey(key);
      } catch (e) {
        // Safer error handling
        const message = e instanceof Error ? e.message : String(e);
        console.error(`Invalid public key string provided: ${key}`, message);
        throw new Error(`Invalid public key string: ${key}`);
      }
    } else if (key instanceof PublicKey) {
       // Use the provided PublicKey instance directly
      pkInstance = key;
    } else {
      // Handle invalid input type
      throw new Error('Invalid input for Address.publicKey: Must be a PublicKey instance or a base58 string.');
    }
    // Return the structured AddressType object
    return {
      type: 'address',
      publicKey: pkInstance,
    };
  },
};

// --- Common Interfaces ---
/**
 * Common metadata fields added by TaroBase to document responses.
 */
export interface TarobaseMetadata {
  id: string;
  tarobase_created_at: number; // epoch milliseconds
}

/**
 * Represents a file stored in TaroBase Storage.
 */
export interface FileItem {
  path: string; // Full path within storage
  url: string;  // Publicly accessible URL
}

/**
 * Represents a document operation for use with setMany.
 * Used by build functions to create properly typed operations.
 */
export interface DocumentOperation {
  path: string;
  document: any;
}

// --- Batch Operations ---

/**
 * Execute multiple document operations in a single batch.
 * @param operations Array of DocumentOperation objects created by build functions
 * @returns Promise resolving to the result of the batch operation
 */
export async function setMany(operations: DocumentOperation[]): Promise<any> {
  return await tarobaseSetMany(operations);
}

// --- Generated Functions by Policy Path ---

// --- Path: fundManagers/$managerId ---

export interface FundManagersRequest {
  walletAddress: AddressType;
  twitterHandle?: string;
  twitterVerified: boolean;
  feePercentageBps: number | TimeOperation | IncrementOperation | TokenAmount;
  strategyDescription: string;
  totalTvlLamports: number | TimeOperation | IncrementOperation | TokenAmount;
  performanceScore?: number | TimeOperation | IncrementOperation | TokenAmount;
  reputationScore?: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface FundManagersResponse {
  walletAddress: string;
  twitterHandle?: string;
  twitterVerified: boolean;
  feePercentageBps: number;
  strategyDescription: string;
  totalTvlLamports: number;
  performanceScore?: number;
  reputationScore?: number;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a FundManagers operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildFundManagers(managerId: string, data: FundManagersRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `fundManagers/${managerId}`, document: doc };
}

/**
 * Authenticated users can register as fund managers by providing their wallet address, Twitter handle, fee percentage (max 20%), and strategy description. The caller's wallet address must match the managerId. (Create/Update Single Item)
 */
export async function setFundManagers(managerId: string, data: FundManagersRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`fundManagers/${managerId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting FundManagers: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

export type FundManagersRequestUpdate = Partial<FundManagersRequest>;

/**
 * Build a FundManagers update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateFundManagers(managerId: string, data: FundManagersRequestUpdate): DocumentOperation {
  const doc = transformValues(data);
  return { path: `fundManagers/${managerId}`, document: doc };
}

/**
 * Only the fund manager (wallet address matches managerId) can update their own profile fields such as fee percentage, strategy description, or Twitter verification status. (Update Single Item)
 */
export async function updateFundManagers(managerId: string, data: FundManagersRequestUpdate): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`fundManagers/${managerId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error updating FundManagers: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can read fund manager profiles to view performance metrics, fee structures, and strategy descriptions.
   (Get Single Item)
 */
export async function getFundManagers(managerId: string): Promise<FundManagersResponse | null> {
  try {
    const result = await get(`fundManagers/${managerId}`);
    return result as FundManagersResponse | null;
  } catch (error) {
    console.error(`Error getting FundManagers: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single FundManagers document. (
  Read Operation Details: Anyone can read fund manager profiles to view performance metrics, fee structures, and strategy descriptions.
  )
 */
export function subscribeFundManagers(callback: (data: FundManagersResponse | null) => void, managerId: string): Promise<() => Promise<void>> {
  return subscribe(`fundManagers/${managerId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as FundManagersResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to FundManagers at path '${`fundManagers/${managerId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many FundManagers items from collection fundManagers
 
  Read Operation Details: Anyone can read fund manager profiles to view performance metrics, fee structures, and strategy descriptions.
  
 */
export async function getManyFundManagers(filter: string = ""): Promise<FundManagersResponse[]> {
  try {
    const results = await get("fundManagers", { prompt: filter });
    return Array.isArray(results) ? results as FundManagersResponse[] : [];
  } catch (error) {
    console.error(`Error getting FundManagers collection at path 'fundManagers': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in FundManagers collection at fundManagers
 
  Read Operation Details: Anyone can read fund manager profiles to view performance metrics, fee structures, and strategy descriptions.
  
 */
export function subscribeManyFundManagers(callback: (data: FundManagersResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("fundManagers", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as FundManagersResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to FundManagers collection at path '${"fundManagers"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all FundManagers items from collection fundManagers
 
  Read Operation Details: Anyone can read fund manager profiles to view performance metrics, fee structures, and strategy descriptions.
  
 */
export async function getAllFundManagers(filter: string = ""): Promise<FundManagersResponse[]> {
  try {
    const results = await get("fundManagers", { prompt: filter });
    return Array.isArray(results) ? results as FundManagersResponse[] : [];
  } catch (error) {
    console.error(`Error getting FundManagers collection at path 'fundManagers': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in FundManagers collection at fundManagers
 
  Read Operation Details: Anyone can read fund manager profiles to view performance metrics, fee structures, and strategy descriptions.
  
 */
export function subscribeAllFundManagers(callback: (data: FundManagersResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("fundManagers", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as FundManagersResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to FundManagers collection at path '${"fundManagers"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * 
  Delete Operation Details: Fund managers can delete their own profiles if they have no active fund pools.
   (Delete Single Item)
 */
export async function deleteFundManagers(managerId: string): Promise<boolean> {
  try {
    const succeeded = await set(`fundManagers/${managerId}`, null);
    return !!succeeded;
  } catch (error) {
    console.error(`Error deleting FundManagers: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * Build a delete operation for FundManagers for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildDeleteFundManagers(managerId: string): DocumentOperation {
  return { path: `fundManagers/${managerId}`, document: null };
}

// --- Path: fundPools/$poolId ---

export interface FundPoolsRequest {
  managerAddress: AddressType;
  fundTokenMint?: AddressType;
  totalDepositsLamports: number | TimeOperation | IncrementOperation | TokenAmount;
  currentTvlLamports: number | TimeOperation | IncrementOperation | TokenAmount;
  fundTokenSupply: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface FundPoolsResponse {
  managerAddress: string;
  fundTokenMint?: string;
  totalDepositsLamports: number;
  currentTvlLamports: number;
  fundTokenSupply: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a FundPools operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildFundPools(poolId: string, data: FundPoolsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `fundPools/${poolId}`, document: doc };
}

/**
 * Authenticated fund managers can create a new fund pool. The poolId must match the manager's wallet address. Creates the fund token mint and initializes the pool with zero TVL. (Create/Update Single Item)
 */
export async function setFundPools(poolId: string, data: FundPoolsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`fundPools/${poolId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting FundPools: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

export type FundPoolsRequestUpdate = Partial<FundPoolsRequest>;

/**
 * Build a FundPools update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateFundPools(poolId: string, data: FundPoolsRequestUpdate): DocumentOperation {
  const doc = transformValues(data);
  return { path: `fundPools/${poolId}`, document: doc };
}

/**
 * Only the fund manager can update pool data such as TVL and total deposits. Updates occur automatically through deposit/withdrawal hooks. (Update Single Item)
 */
export async function updateFundPools(poolId: string, data: FundPoolsRequestUpdate): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`fundPools/${poolId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error updating FundPools: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can read fund pool data to view TVL, manager information, and fund token details.
   (Get Single Item)
 */
export async function getFundPools(poolId: string): Promise<FundPoolsResponse | null> {
  try {
    const result = await get(`fundPools/${poolId}`);
    return result as FundPoolsResponse | null;
  } catch (error) {
    console.error(`Error getting FundPools: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single FundPools document. (
  Read Operation Details: Anyone can read fund pool data to view TVL, manager information, and fund token details.
  )
 */
export function subscribeFundPools(callback: (data: FundPoolsResponse | null) => void, poolId: string): Promise<() => Promise<void>> {
  return subscribe(`fundPools/${poolId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as FundPoolsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to FundPools at path '${`fundPools/${poolId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many FundPools items from collection fundPools
 
  Read Operation Details: Anyone can read fund pool data to view TVL, manager information, and fund token details.
  
 */
export async function getManyFundPools(filter: string = ""): Promise<FundPoolsResponse[]> {
  try {
    const results = await get("fundPools", { prompt: filter });
    return Array.isArray(results) ? results as FundPoolsResponse[] : [];
  } catch (error) {
    console.error(`Error getting FundPools collection at path 'fundPools': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in FundPools collection at fundPools
 
  Read Operation Details: Anyone can read fund pool data to view TVL, manager information, and fund token details.
  
 */
export function subscribeManyFundPools(callback: (data: FundPoolsResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("fundPools", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as FundPoolsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to FundPools collection at path '${"fundPools"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all FundPools items from collection fundPools
 
  Read Operation Details: Anyone can read fund pool data to view TVL, manager information, and fund token details.
  
 */
export async function getAllFundPools(filter: string = ""): Promise<FundPoolsResponse[]> {
  try {
    const results = await get("fundPools", { prompt: filter });
    return Array.isArray(results) ? results as FundPoolsResponse[] : [];
  } catch (error) {
    console.error(`Error getting FundPools collection at path 'fundPools': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in FundPools collection at fundPools
 
  Read Operation Details: Anyone can read fund pool data to view TVL, manager information, and fund token details.
  
 */
export function subscribeAllFundPools(callback: (data: FundPoolsResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("fundPools", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as FundPoolsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to FundPools collection at path '${"fundPools"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Runs the "getFundTokenMint" query on FundPools.
 * Query Logic: @TokenPlugin.getTokenMintAddress($poolId, $poolId, $poolId)
 */
export async function runGetFundTokenMintQueryForFundPools(poolId: string, ): Promise<string> {
  try {
    const result = await runQuery(`fundPools/${poolId}`, "getFundTokenMint", {});
    return result as string;
  } catch (error) {
    console.error(`Error running query "getFundTokenMint" on FundPools: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

/**
 * Runs the "getPoolSolBalance" query on FundPools.
 * Query Logic: @TokenPlugin.getBalance($poolId, @TokenPlugin.SOL)
 */
export async function runGetPoolSolBalanceQueryForFundPools(poolId: string, ): Promise<number> {
  try {
    const result = await runQuery(`fundPools/${poolId}`, "getPoolSolBalance", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getPoolSolBalance" on FundPools: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// --- Path: fundPools/$poolId/deposits/$depositId ---

export interface FundPoolsDepositsRequest {
  userAddress: AddressType;
  amountLamports: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface FundPoolsDepositsResponse {
  userAddress: string;
  amountLamports: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a FundPoolsDeposits operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildFundPoolsDeposits(poolId: string, depositId: string, data: FundPoolsDepositsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `fundPools/${poolId}/deposits/${depositId}`, document: doc };
}

/**
 * Authenticated users can deposit SOL to a fund pool. The deposit amount must be greater than zero. Fund tokens are minted to the user based on the current TVL. If the pool is empty, fund tokens are minted 1:1 with lamports deposited. Otherwise, fund tokens are calculated proportionally to maintain share value. (Create/Update Single Item)
 */
export async function setFundPoolsDeposits(poolId: string, depositId: string, data: FundPoolsDepositsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`fundPools/${poolId}/deposits/${depositId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting FundPoolsDeposits: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can read deposit records to view deposit history.
   (Get Single Item)
 */
export async function getFundPoolsDeposits(poolId: string, depositId: string): Promise<FundPoolsDepositsResponse | null> {
  try {
    const result = await get(`fundPools/${poolId}/deposits/${depositId}`);
    return result as FundPoolsDepositsResponse | null;
  } catch (error) {
    console.error(`Error getting FundPoolsDeposits: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single FundPoolsDeposits document. (
  Read Operation Details: Anyone can read deposit records to view deposit history.
  )
 */
export function subscribeFundPoolsDeposits(callback: (data: FundPoolsDepositsResponse | null) => void, poolId: string, depositId: string): Promise<() => Promise<void>> {
  return subscribe(`fundPools/${poolId}/deposits/${depositId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as FundPoolsDepositsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to FundPoolsDeposits at path '${`fundPools/${poolId}/deposits/${depositId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many FundPoolsDeposits items from collection fundPools/${poolId}/deposits
 
  Read Operation Details: Anyone can read deposit records to view deposit history.
  
 */
export async function getManyFundPoolsDeposits(poolId: string, filter: string = ""): Promise<FundPoolsDepositsResponse[]> {
  try {
    const results = await get(`fundPools/${poolId}/deposits`, { prompt: filter });
    return Array.isArray(results) ? results as FundPoolsDepositsResponse[] : [];
  } catch (error) {
    console.error(`Error getting FundPoolsDeposits collection at path 'fundPools/${poolId}/deposits': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in FundPoolsDeposits collection at fundPools/${poolId}/deposits
 
  Read Operation Details: Anyone can read deposit records to view deposit history.
  
 */
export function subscribeManyFundPoolsDeposits(callback: (data: FundPoolsDepositsResponse[]) => void, poolId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`fundPools/${poolId}/deposits`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as FundPoolsDepositsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to FundPoolsDeposits collection at path '${`fundPools/${poolId}/deposits`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all FundPoolsDeposits items from collection fundPools/${poolId}/deposits
 
  Read Operation Details: Anyone can read deposit records to view deposit history.
  
 */
export async function getAllFundPoolsDeposits(poolId: string, filter: string = ""): Promise<FundPoolsDepositsResponse[]> {
  try {
    const results = await get(`fundPools/*/deposits`, { prompt: filter });
    return Array.isArray(results) ? results as FundPoolsDepositsResponse[] : [];
  } catch (error) {
    console.error(`Error getting FundPoolsDeposits collection at path 'fundPools/${poolId}/deposits': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in FundPoolsDeposits collection at fundPools/${poolId}/deposits
 
  Read Operation Details: Anyone can read deposit records to view deposit history.
  
 */
export function subscribeAllFundPoolsDeposits(callback: (data: FundPoolsDepositsResponse[]) => void, poolId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`fundPools/*/deposits`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as FundPoolsDepositsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to FundPoolsDeposits collection at path '${`fundPools/*/deposits`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

// --- Path: userAllocations/$userId/funds/$fundId ---

export interface UserAllocationsFundsRequest {
  userAddress: AddressType;
  fundPoolId: string;
  fundTokenAmount: number | TimeOperation | IncrementOperation | TokenAmount;
  lastWithdrawalTimestamp?: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface UserAllocationsFundsResponse {
  userAddress: string;
  fundPoolId: string;
  fundTokenAmount: number;
  lastWithdrawalTimestamp?: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a UserAllocationsFunds operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUserAllocationsFunds(userId: string, fundId: string, data: UserAllocationsFundsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `userAllocations/${userId}/funds/${fundId}`, document: doc };
}

/**
 * Authenticated users can create allocation records when they first deposit to a fund. The userId must match the caller's wallet address. (Create/Update Single Item)
 */
export async function setUserAllocationsFunds(userId: string, fundId: string, data: UserAllocationsFundsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`userAllocations/${userId}/funds/${fundId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting UserAllocationsFunds: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

export type UserAllocationsFundsRequestUpdate = Partial<UserAllocationsFundsRequest>;

/**
 * Build a UserAllocationsFunds update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateUserAllocationsFunds(userId: string, fundId: string, data: UserAllocationsFundsRequestUpdate): DocumentOperation {
  const doc = transformValues(data);
  return { path: `userAllocations/${userId}/funds/${fundId}`, document: doc };
}

/**
 * Users can update their allocation records, typically through deposit or withdrawal operations that change token amounts and timestamps. (Update Single Item)
 */
export async function updateUserAllocationsFunds(userId: string, fundId: string, data: UserAllocationsFundsRequestUpdate): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`userAllocations/${userId}/funds/${fundId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error updating UserAllocationsFunds: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can read user allocations to view fund token holdings.
   (Get Single Item)
 */
export async function getUserAllocationsFunds(userId: string, fundId: string): Promise<UserAllocationsFundsResponse | null> {
  try {
    const result = await get(`userAllocations/${userId}/funds/${fundId}`);
    return result as UserAllocationsFundsResponse | null;
  } catch (error) {
    console.error(`Error getting UserAllocationsFunds: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single UserAllocationsFunds document. (
  Read Operation Details: Anyone can read user allocations to view fund token holdings.
  )
 */
export function subscribeUserAllocationsFunds(callback: (data: UserAllocationsFundsResponse | null) => void, userId: string, fundId: string): Promise<() => Promise<void>> {
  return subscribe(`userAllocations/${userId}/funds/${fundId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as UserAllocationsFundsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to UserAllocationsFunds at path '${`userAllocations/${userId}/funds/${fundId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many UserAllocationsFunds items from collection userAllocations/${userId}/funds
 
  Read Operation Details: Anyone can read user allocations to view fund token holdings.
  
 */
export async function getManyUserAllocationsFunds(userId: string, filter: string = ""): Promise<UserAllocationsFundsResponse[]> {
  try {
    const results = await get(`userAllocations/${userId}/funds`, { prompt: filter });
    return Array.isArray(results) ? results as UserAllocationsFundsResponse[] : [];
  } catch (error) {
    console.error(`Error getting UserAllocationsFunds collection at path 'userAllocations/${userId}/funds': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in UserAllocationsFunds collection at userAllocations/${userId}/funds
 
  Read Operation Details: Anyone can read user allocations to view fund token holdings.
  
 */
export function subscribeManyUserAllocationsFunds(callback: (data: UserAllocationsFundsResponse[]) => void, userId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`userAllocations/${userId}/funds`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as UserAllocationsFundsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to UserAllocationsFunds collection at path '${`userAllocations/${userId}/funds`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all UserAllocationsFunds items from collection userAllocations/${userId}/funds
 
  Read Operation Details: Anyone can read user allocations to view fund token holdings.
  
 */
export async function getAllUserAllocationsFunds(userId: string, filter: string = ""): Promise<UserAllocationsFundsResponse[]> {
  try {
    const results = await get(`userAllocations/*/funds`, { prompt: filter });
    return Array.isArray(results) ? results as UserAllocationsFundsResponse[] : [];
  } catch (error) {
    console.error(`Error getting UserAllocationsFunds collection at path 'userAllocations/${userId}/funds': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in UserAllocationsFunds collection at userAllocations/${userId}/funds
 
  Read Operation Details: Anyone can read user allocations to view fund token holdings.
  
 */
export function subscribeAllUserAllocationsFunds(callback: (data: UserAllocationsFundsResponse[]) => void, userId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`userAllocations/*/funds`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as UserAllocationsFundsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to UserAllocationsFunds collection at path '${`userAllocations/*/funds`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * 
  Delete Operation Details: Users can delete their allocation records when they fully withdraw from a fund.
   (Delete Single Item)
 */
export async function deleteUserAllocationsFunds(userId: string, fundId: string): Promise<boolean> {
  try {
    const succeeded = await set(`userAllocations/${userId}/funds/${fundId}`, null);
    return !!succeeded;
  } catch (error) {
    console.error(`Error deleting UserAllocationsFunds: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * Build a delete operation for UserAllocationsFunds for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildDeleteUserAllocationsFunds(userId: string, fundId: string): DocumentOperation {
  return { path: `userAllocations/${userId}/funds/${fundId}`, document: null };
}

// --- Path: userAllocations/$userId/funds/$fundId/withdrawals/$withdrawalId ---

export interface UserAllocationsFundsWithdrawalsRequest {
  fundTokenAmount: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface UserAllocationsFundsWithdrawalsResponse {
  fundTokenAmount: number;
  id: string;
  tarobase_created_at: number;
  tarobase_transaction_hash?: string | undefined; // Represents the hash of the transaction that created this item. Can be used to create Solscan links (combine with the current network in the Tarobase app)
}

/**
 * Build a UserAllocationsFundsWithdrawals operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUserAllocationsFundsWithdrawals(userId: string, fundId: string, withdrawalId: string, data: UserAllocationsFundsWithdrawalsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `userAllocations/${userId}/funds/${fundId}/withdrawals/${withdrawalId}`, document: doc };
}

/**
 * Authenticated users can withdraw from a fund pool by burning their fund tokens. The withdrawal must respect the cooldown period (24 hours since last withdrawal). Fund tokens are burned and SOL is transferred from the pool to the user proportionally to their share. Performance fees are deducted and sent to the fund manager. (Create/Update Single Item)
 */
export async function setUserAllocationsFundsWithdrawals(userId: string, fundId: string, withdrawalId: string, data: UserAllocationsFundsWithdrawalsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`userAllocations/${userId}/funds/${fundId}/withdrawals/${withdrawalId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting UserAllocationsFundsWithdrawals: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can read withdrawal records to view withdrawal history.
   (Get Single Item)
 */
export async function getUserAllocationsFundsWithdrawals(userId: string, fundId: string, withdrawalId: string): Promise<UserAllocationsFundsWithdrawalsResponse | null> {
  try {
    const result = await get(`userAllocations/${userId}/funds/${fundId}/withdrawals/${withdrawalId}`);
    return result as UserAllocationsFundsWithdrawalsResponse | null;
  } catch (error) {
    console.error(`Error getting UserAllocationsFundsWithdrawals: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single UserAllocationsFundsWithdrawals document. (
  Read Operation Details: Anyone can read withdrawal records to view withdrawal history.
  )
 */
export function subscribeUserAllocationsFundsWithdrawals(callback: (data: UserAllocationsFundsWithdrawalsResponse | null) => void, userId: string, fundId: string, withdrawalId: string): Promise<() => Promise<void>> {
  return subscribe(`userAllocations/${userId}/funds/${fundId}/withdrawals/${withdrawalId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as UserAllocationsFundsWithdrawalsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to UserAllocationsFundsWithdrawals at path '${`userAllocations/${userId}/funds/${fundId}/withdrawals/${withdrawalId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many UserAllocationsFundsWithdrawals items from collection userAllocations/${userId}/funds/${fundId}/withdrawals
 
  Read Operation Details: Anyone can read withdrawal records to view withdrawal history.
  
 */
export async function getManyUserAllocationsFundsWithdrawals(userId: string, fundId: string, filter: string = ""): Promise<UserAllocationsFundsWithdrawalsResponse[]> {
  try {
    const results = await get(`userAllocations/${userId}/funds/${fundId}/withdrawals`, { prompt: filter });
    return Array.isArray(results) ? results as UserAllocationsFundsWithdrawalsResponse[] : [];
  } catch (error) {
    console.error(`Error getting UserAllocationsFundsWithdrawals collection at path 'userAllocations/${userId}/funds/${fundId}/withdrawals': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in UserAllocationsFundsWithdrawals collection at userAllocations/${userId}/funds/${fundId}/withdrawals
 
  Read Operation Details: Anyone can read withdrawal records to view withdrawal history.
  
 */
export function subscribeManyUserAllocationsFundsWithdrawals(callback: (data: UserAllocationsFundsWithdrawalsResponse[]) => void, userId: string, fundId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`userAllocations/${userId}/funds/${fundId}/withdrawals`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as UserAllocationsFundsWithdrawalsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to UserAllocationsFundsWithdrawals collection at path '${`userAllocations/${userId}/funds/${fundId}/withdrawals`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all UserAllocationsFundsWithdrawals items from collection userAllocations/${userId}/funds/${fundId}/withdrawals
 
  Read Operation Details: Anyone can read withdrawal records to view withdrawal history.
  
 */
export async function getAllUserAllocationsFundsWithdrawals(userId: string, fundId: string, filter: string = ""): Promise<UserAllocationsFundsWithdrawalsResponse[]> {
  try {
    const results = await get(`userAllocations/*/funds/*/withdrawals`, { prompt: filter });
    return Array.isArray(results) ? results as UserAllocationsFundsWithdrawalsResponse[] : [];
  } catch (error) {
    console.error(`Error getting UserAllocationsFundsWithdrawals collection at path 'userAllocations/${userId}/funds/${fundId}/withdrawals': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in UserAllocationsFundsWithdrawals collection at userAllocations/${userId}/funds/${fundId}/withdrawals
 
  Read Operation Details: Anyone can read withdrawal records to view withdrawal history.
  
 */
export function subscribeAllUserAllocationsFundsWithdrawals(callback: (data: UserAllocationsFundsWithdrawalsResponse[]) => void, userId: string, fundId: string, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe(`userAllocations/*/funds/*/withdrawals`, {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as UserAllocationsFundsWithdrawalsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to UserAllocationsFundsWithdrawals collection at path '${`userAllocations/*/funds/*/withdrawals`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Runs the "getUserFundTokenBalance" query on UserAllocationsFundsWithdrawals.
 * Query Logic: @TokenPlugin.getBalance(@user.address, @TokenPlugin.getTokenMintAddress($fundId, $fundId, $fundId))
 */
export async function runGetUserFundTokenBalanceQueryForUserAllocationsFundsWithdrawals(userId: string, fundId: string, withdrawalId: string, ): Promise<number> {
  try {
    const result = await runQuery(`userAllocations/${userId}/funds/${fundId}/withdrawals/${withdrawalId}`, "getUserFundTokenBalance", {});
    return result as number;
  } catch (error) {
    console.error(`Error running query "getUserFundTokenBalance" on UserAllocationsFundsWithdrawals: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

/** Arguments accepted by the "getWithdrawalAmount" query on UserAllocationsFundsWithdrawals. */
interface UserAllocationsFundsWithdrawalsGetWithdrawalAmountArgs {
  fundTokenAmount: string;
}

/**
 * Runs the "getWithdrawalAmount" query on UserAllocationsFundsWithdrawals.
 * Query Logic: (@newData.fundTokenAmount * @data.currentTvlLamports) // @data.fundTokenSupply
 */
export async function runGetWithdrawalAmountQueryForUserAllocationsFundsWithdrawals(userId: string, fundId: string, withdrawalId: string, args: UserAllocationsFundsWithdrawalsGetWithdrawalAmountArgs): Promise<number> {
  try {
    const result = await runQuery(`userAllocations/${userId}/funds/${fundId}/withdrawals/${withdrawalId}`, "getWithdrawalAmount", args);
    return result as number;
  } catch (error) {
    console.error(`Error running query "getWithdrawalAmount" on UserAllocationsFundsWithdrawals: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// --- Path: transactions/$txId ---

export interface TransactionsRequest {
  userAddress: AddressType;
  fundPoolId: string;
  txType: string;
  amountLamports: number | TimeOperation | IncrementOperation | TokenAmount;
  fundTokenChange: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface TransactionsResponse {
  userAddress: string;
  fundPoolId: string;
  txType: string;
  amountLamports: number;
  fundTokenChange: number;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a Transactions operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildTransactions(txId: string, data: TransactionsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `transactions/${txId}`, document: doc };
}

/**
 * Authenticated users can create transaction records when they perform fund operations. The transaction type must be one of: deposit, withdraw, or rebalance. (Create/Update Single Item)
 */
export async function setTransactions(txId: string, data: TransactionsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`transactions/${txId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting Transactions: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can read transaction records to view fund operation history.
   (Get Single Item)
 */
export async function getTransactions(txId: string): Promise<TransactionsResponse | null> {
  try {
    const result = await get(`transactions/${txId}`);
    return result as TransactionsResponse | null;
  } catch (error) {
    console.error(`Error getting Transactions: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single Transactions document. (
  Read Operation Details: Anyone can read transaction records to view fund operation history.
  )
 */
export function subscribeTransactions(callback: (data: TransactionsResponse | null) => void, txId: string): Promise<() => Promise<void>> {
  return subscribe(`transactions/${txId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as TransactionsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to Transactions at path '${`transactions/${txId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many Transactions items from collection transactions
 
  Read Operation Details: Anyone can read transaction records to view fund operation history.
  
 */
export async function getManyTransactions(filter: string = ""): Promise<TransactionsResponse[]> {
  try {
    const results = await get("transactions", { prompt: filter });
    return Array.isArray(results) ? results as TransactionsResponse[] : [];
  } catch (error) {
    console.error(`Error getting Transactions collection at path 'transactions': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in Transactions collection at transactions
 
  Read Operation Details: Anyone can read transaction records to view fund operation history.
  
 */
export function subscribeManyTransactions(callback: (data: TransactionsResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("transactions", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as TransactionsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to Transactions collection at path '${"transactions"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all Transactions items from collection transactions
 
  Read Operation Details: Anyone can read transaction records to view fund operation history.
  
 */
export async function getAllTransactions(filter: string = ""): Promise<TransactionsResponse[]> {
  try {
    const results = await get("transactions", { prompt: filter });
    return Array.isArray(results) ? results as TransactionsResponse[] : [];
  } catch (error) {
    console.error(`Error getting Transactions collection at path 'transactions': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in Transactions collection at transactions
 
  Read Operation Details: Anyone can read transaction records to view fund operation history.
  
 */
export function subscribeAllTransactions(callback: (data: TransactionsResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("transactions", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as TransactionsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to Transactions collection at path '${"transactions"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

// --- Path: protocolConfig/$configId ---

export interface ProtocolConfigRequest {
  protocolFeeBps: number | TimeOperation | IncrementOperation | TokenAmount;
  withdrawalCooldownSeconds: number | TimeOperation | IncrementOperation | TokenAmount;
  largeWithdrawalTimelockSeconds: number | TimeOperation | IncrementOperation | TokenAmount;
  largeWithdrawalThresholdLamports: number | TimeOperation | IncrementOperation | TokenAmount;
}

export interface ProtocolConfigResponse {
  protocolFeeBps: number;
  withdrawalCooldownSeconds: number;
  largeWithdrawalTimelockSeconds: number;
  largeWithdrawalThresholdLamports: number;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a ProtocolConfig operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildProtocolConfig(configId: string, data: ProtocolConfigRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `protocolConfig/${configId}`, document: doc };
}

/**
 * Only the admin can create protocol configuration. Used for initial setup. (Create/Update Single Item)
 */
export async function setProtocolConfig(configId: string, data: ProtocolConfigRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`protocolConfig/${configId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting ProtocolConfig: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

export type ProtocolConfigRequestUpdate = Partial<ProtocolConfigRequest>;

/**
 * Build a ProtocolConfig update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateProtocolConfig(configId: string, data: ProtocolConfigRequestUpdate): DocumentOperation {
  const doc = transformValues(data);
  return { path: `protocolConfig/${configId}`, document: doc };
}

/**
 * Only the admin can update protocol configuration parameters. (Update Single Item)
 */
export async function updateProtocolConfig(configId: string, data: ProtocolConfigRequestUpdate): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`protocolConfig/${configId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error updating ProtocolConfig: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Anyone can read protocol configuration to understand system parameters.
   (Get Single Item)
 */
export async function getProtocolConfig(configId: string): Promise<ProtocolConfigResponse | null> {
  try {
    const result = await get(`protocolConfig/${configId}`);
    return result as ProtocolConfigResponse | null;
  } catch (error) {
    console.error(`Error getting ProtocolConfig: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single ProtocolConfig document. (
  Read Operation Details: Anyone can read protocol configuration to understand system parameters.
  )
 */
export function subscribeProtocolConfig(callback: (data: ProtocolConfigResponse | null) => void, configId: string): Promise<() => Promise<void>> {
  return subscribe(`protocolConfig/${configId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as ProtocolConfigResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to ProtocolConfig at path '${`protocolConfig/${configId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many ProtocolConfig items from collection protocolConfig
 
  Read Operation Details: Anyone can read protocol configuration to understand system parameters.
  
 */
export async function getManyProtocolConfig(filter: string = ""): Promise<ProtocolConfigResponse[]> {
  try {
    const results = await get("protocolConfig", { prompt: filter });
    return Array.isArray(results) ? results as ProtocolConfigResponse[] : [];
  } catch (error) {
    console.error(`Error getting ProtocolConfig collection at path 'protocolConfig': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in ProtocolConfig collection at protocolConfig
 
  Read Operation Details: Anyone can read protocol configuration to understand system parameters.
  
 */
export function subscribeManyProtocolConfig(callback: (data: ProtocolConfigResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("protocolConfig", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as ProtocolConfigResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to ProtocolConfig collection at path '${"protocolConfig"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all ProtocolConfig items from collection protocolConfig
 
  Read Operation Details: Anyone can read protocol configuration to understand system parameters.
  
 */
export async function getAllProtocolConfig(filter: string = ""): Promise<ProtocolConfigResponse[]> {
  try {
    const results = await get("protocolConfig", { prompt: filter });
    return Array.isArray(results) ? results as ProtocolConfigResponse[] : [];
  } catch (error) {
    console.error(`Error getting ProtocolConfig collection at path 'protocolConfig': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in ProtocolConfig collection at protocolConfig
 
  Read Operation Details: Anyone can read protocol configuration to understand system parameters.
  
 */
export function subscribeAllProtocolConfig(callback: (data: ProtocolConfigResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("protocolConfig", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as ProtocolConfigResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to ProtocolConfig collection at path '${"protocolConfig"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

// --- Path: uniblock/$requestId ---

// --- Path: uniblock/$requestId --- (Uniblock  typed wrappers, hardcoded requestId=1)

export type UniblockChainId =
  | 'solana'
  | 'solana-devnet'
  | 1 | 8453 | 42161 | number;

export interface WalletTokenBalanceParams { walletAddress: string; chainId?: UniblockChainId; }
export interface WalletTokenBalanceResponseItem { contractAddress: string; balance: string; name: string; symbol: string; logo: string; decimals: string; }
export interface WalletTokenBalanceResponse { balances: WalletTokenBalanceResponseItem[]; }
export async function getWalletTokenBalance({ walletAddress, chainId = 'solana' }: WalletTokenBalanceParams): Promise<WalletTokenBalanceResponse> {
  const body = { operationId: 'WalletTokenBalance', operationInputData: { walletAddress, chainId, includePrice: true } };
  return (await set("uniblock/1", body)) as WalletTokenBalanceResponse;
}

export interface TokenPriceParams { contractAddress: string; chainId?: UniblockChainId; }
export interface TokenPriceResponse { usdPrice: string; name: string; symbol: string; address: string; decimals: string; logo: string; exchangeName: string; exchangeAddress: string; updatedAt: string; }
export async function getTokenPrice({ contractAddress, chainId = 'solana' }: TokenPriceParams): Promise<TokenPriceResponse> {
  const body = { operationId: 'TokenPrice', operationInputData: { contractAddress, chainId } };
  return (await set("uniblock/1", body)) as TokenPriceResponse;
}

export interface TokenHistoricalPriceParams { contractAddress: string; chainId?: UniblockChainId; timestamp?: number; blockNumber?: number; }
export interface TokenHistoricalPriceResponse { usdPrice: string; name: string; symbol: string; address: string; decimals: string; logo: string; exchangeName: string; exchangeAddress: string; updatedAt: string; blockNumber: string; timestamp: string; }
export async function getTokenHistoricalPrice({ contractAddress, chainId = 'solana', timestamp, blockNumber }: TokenHistoricalPriceParams): Promise<TokenHistoricalPriceResponse> {
  const body = { operationId: 'TokenHistoricalPrice', operationInputData: { contractAddress, chainId, timestamp, blockNumber } };
  return (await set("uniblock/1", body)) as TokenHistoricalPriceResponse;
}

export interface WalletNFTBalanceParams { walletAddress: string; chainId?: UniblockChainId; }
export interface WalletNFTBalanceResponseItem { contractAddress: string; tokenId: string; name: string; symbol: string; image: string; }
export interface WalletNFTBalanceResponse { balances: WalletNFTBalanceResponseItem[]; }
export async function getWalletNFTBalance({ walletAddress, chainId = 'solana' }: WalletNFTBalanceParams): Promise<WalletNFTBalanceResponse> {
  const body = { operationId: 'WalletNFTBalance', operationInputData: { walletAddress, chainId } };
  return (await set("uniblock/1", body)) as WalletNFTBalanceResponse;
}

export interface NFTCollectionMetadataParams { contractAddress: string; chainId?: UniblockChainId; }
export interface NFTCollectionMetadataResponse { address: string; name: string; symbol: string; type: string; }
export async function getNFTCollectionMetadata({ contractAddress, chainId = 'solana' }: NFTCollectionMetadataParams): Promise<NFTCollectionMetadataResponse> {
  const body = { operationId: 'NFTCollectionMetadata', operationInputData: { contractAddress, chainId } };
  return (await set("uniblock/1", body)) as NFTCollectionMetadataResponse;
}

export interface NFTMetadataParams { contractAddress: string; tokenId: string; chainId?: UniblockChainId; }
export interface NFTMetadataResponse { contractAddress: string; contractType: string; metadata: any; rawMetadata: string; lastUpdated: string; contractMetadata: any; }
export async function getNFTMetadata({ contractAddress, tokenId, chainId = 'solana' }: NFTMetadataParams): Promise<NFTMetadataResponse> {
  const body = { operationId: 'NFTMetadata', operationInputData: { contractAddress, tokenId, chainId } };
  return (await set("uniblock/1", body)) as NFTMetadataResponse;
}

export interface TokenMetadataParams { tokenAddress: string; chainId?: UniblockChainId; }
export interface TokenMetadataResponse { name: string; symbol: string; logo: string; decimals: string; }
export async function getTokenMetadata({ tokenAddress, chainId = 'solana' }: TokenMetadataParams): Promise<TokenMetadataResponse> {
  const body = { operationId: 'TokenMetadata', operationInputData: { tokenAddress, chainId } };
  return (await set("uniblock/1", body)) as TokenMetadataResponse;
}
// --- Path: appFiles/$fileId ---

/**
 * Handles AppFiles files (Get Single File based on its ID, null if not found)
 */
export async function getAppFiles(fileId: string): Promise<FileItem | null> {
  try {
    const rawResult = await getFiles(`appFiles/${fileId}`);
    if (!rawResult || !Array.isArray(rawResult) || rawResult.length === 0) return null;
    return rawResult[0] as FileItem;
  } catch (error) {
    console.error(`Error getting file AppFiles: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Handles AppFiles files (Upload/Replace a File and persist it keyed by its ID) To get the file URL use the getAppFiles function right after this one.
 */
export async function uploadAppFiles(fileId: string, file: File): Promise<boolean> {
  try {
    const pathUsed = `appFiles/${fileId}`;
    const result = await setFile(pathUsed, file);
    return !!result;
  } catch (error) {
    console.error(`Error uploading file AppFiles: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// --- Path: uploadedImages/$imageId ---

/**
 * Handles UploadedImages files (Get Single File based on its ID, null if not found)
 */
export async function getUploadedImages(imageId: string): Promise<FileItem | null> {
  try {
    const rawResult = await getFiles(`uploadedImages/${imageId}`);
    if (!rawResult || !Array.isArray(rawResult) || rawResult.length === 0) return null;
    return rawResult[0] as FileItem;
  } catch (error) {
    console.error(`Error getting file UploadedImages: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Handles UploadedImages files (Upload/Replace a File and persist it keyed by its ID) To get the file URL use the getUploadedImages function right after this one.
 */
export async function uploadUploadedImages(imageId: string, file: File): Promise<boolean> {
  try {
    const pathUsed = `uploadedImages/${imageId}`;
    const result = await setFile(pathUsed, file);
    return !!result;
  } catch (error) {
    console.error(`Error uploading file UploadedImages: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * Handles UploadedImages files (Delete File based on its ID, returns true if successful)
 */
export async function deleteUploadedImages(imageId: string): Promise<boolean> {
  try {
    await setFile(`uploadedImages/${imageId}`, null);
    return true;
  } catch (error) {
    console.error(`Error deleting file UploadedImages: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// --- End Generated SDK ---
